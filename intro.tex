\chapter{Introduction}\label{intro}
The \acrfull{CHI}~\cite{curry1934functionality,howard1995formulae} was first established as a deep connection between explicit proofs in intuitionistic logic and programs of a simple programming 
language that includes pairs, functions and union types ~\cite{Pierce:2002:TPL:509043,Srensen98lectureson}. This relation has been a central topic of study in the field of type theory and has turned into the standard
foundational approach to studying and designing programming languages especially of the functional paradigm. Since  this relation has been  established, the 
isomorphism has been extended to more complex logics and correspondingly to more complex programming language constructs.  
In the following I will be using \acrfull{CHI} and \emph{proofs-as-programs} interchangeably.

There are great benefits both for a logician
and the programming language designer in viewing things through the lenses of such a relation. From the programming language perspective certain linguistic phenomena are given categorical characterizations that do not 
depend on implementation specifics. 
For example the designer of the next hot programming language  
knows that adding pairs would have to adhere to the corresponding constructs of 
logical conjunction. In addition, adding more complex design features 
(e.g. state, concurrency, exceptions etc) can be done in a structured, orthogonal, 
and modular way by enriching the underlying logic  and, 
correspondingly, the type system(see e.g. ~\cite{Harper:2012:PFP:2431407,CERVESATO20091044,Ong:1997:CFF:263699.263722,DBLP:conf/popl/Griffin90}).

It should not be a surprise that languages of the typed functional paradigm  
have been gaining traction and more functional design principles are being added 
to languages of the object oriented paradigm. There are two main reasons for this, 
an old and a new. The older reason is mathematical correctness which is strongly 
related to the fact that reasoning about programs (of the lambda calculus and its extensions) 
can be done in an \textit{equational way}, a property that is heavily connected 
to their underlying foundational principles as we will see. Features such as side effects 
or concurrency in the language are reflected via typing. For example,  
a program that changes global state has a type that  says so explicitly. Similarly,  
a program that uses goto mechanisms  would also say register its behavior in its type. 
Alas, even ``unpure", non-functional constructs (state, mutable references) are added 
in a mathematical/ algebraic fashion under the \ac{CHI} disciple. 
As a result, reasoning about properties of such programs is significantly simpler. 
Moreover, under a strongly typed doctrine, important properties of programs are checked 
statically by the type-checker and prior to their execution. 
Henceforth, the need for testing is reduced to verify only non-trivial properties. 


The renewed interest in functional programming owes a lot to the
 difficulties of scaling concurrent programs in traditional programming paradigms. 
 It is very hard  to scale programs that make unlimited use of side effects 
 (such as state change) in an implicit way (i.e. without leaving any trace in their typing)
  from sequential to  multithreaded style of computation. Programming freedoms in traditional 
  languages (paired with the easiness and textbook familiarity of the Von Neumann model) come 
  at a large cost if one takes into account the need for proving 
  correctness. The ``purity" of
   programs in the lambda calculus -- and the delimited ``impurity" in its extensions -- makes 
   writing high-quality concurrent code an easier task. 
   It is exciting to see that important metatheoretic results in the area of combinatory logic as e.g. the Church--Rosser 
   property are the backbone of models for concurrent computation in modern functional languages. 



On the other hand, the logician has good reasons to study logics as rules of program formation and reduction. First of all, 
such designs make logics implementable ``for free"
in modern theorem provers using the programmistic side of the correspondence. 
Secondly the study of logic in such a way has put upfront a  Gentzen-style treatment of logical 
connectives where emphasis is given to the notion of proof, proof structure and proof reduction. 
This has sparked studies for more refined versions of proof relevant deduction than the ones 
discovered under the standard ``axiomatic" approach (e.g. linear logics, substructural logics etc). 
As we will see, the Gentzen-- Brouwer initiative in  logic  does not merely call for change of 
axiomatization but for a ``proof relevant" interpretation of connectives that comes with a
computational taste. Metatheory is also standardized once one studies logic this way;  
scalable techniques have been developed within the area of ``proof-theoretic" semantics 
that make the passing from  natural deduction of a logic to its cut free calculus pretty standard ~\cite{Sieg1998,pfenning2000structural}. 
In other words, treating logics within a Curry -- Howard environment 
enriches logic as a discipline with good organizing principles. 
Finally, proof relevant treatments of logic -- pushed further by ideas of 
\emph{Martin-L\"{o}f Type Theory}~\cite{martin1984intuitionistic} 
have sparked  a renewed interest in  a foundation of mathematics that stems from 
a  treatment of proofs as \textit{the} primitive objects of mathematics. 


In this work, we are interested in the study of  extending  \acrfull{CHI} with basic 
constructive  necessity of justification logic. 
There is a good reason to believe that this should be doable. Justification logic
 is a logic that relates logical necessity with the existence of a proof construct
  and that is exactly what working in  realm of proof relevancy and \ac{CHI} calls for. 
  There are challenges to this task, both syntactical and  semantical. First of all, there
   is a resemblance of the justification logic syntax with that of simple type theory 
   (e.g. the use of the semicolon $a:A$) that  initially might call for an antagonistic relation
    between the two systems. Of course, this is not a substantial issue since the two
     typing relations can be ``colored" in a syntactical way. 
     But resolving the syntactical overload would still leave a  ``meaning" question open;
      namely, how can one read  the need of having two
       proofs of the ``same thing" in a system. 
       The main contribution of this work  
       ~\cite{Pouliasis2016} it that it  shows how such a relation of binding two kinds of
        proof systems is quite natural and gives a basic reading of validity and necessity 
        on first, proof-theoretic principles.  
        We will treat justification logic as a logic of \textit{proof relevant validity}.
         by tracing justification logic back to its 
         origin as an explicit, classical semantics to \ac{BHK} proof constructs. 
         We will present a modal logic that is based on this relation and we will argue
          that such phenomena of binding two kinds of constructions abound both
           in the realm  of mathematical proofs 
           but also in the realm of programming languages  with constructs 
           such as modules, foreign function calls and dynamic linkers.

           This work  is structured in three parts: 
           The first part (\cref{intui,lambda,jllogic}) is a revision of my second examination paper and constitutes 
           a bird's eye view into my 
           research topics:  
           \emph{intuitionistic logic, justified modality} and \emph{type theory}. 
           The relevant systems are introduced syntactically together with main 
            metatheoretic proof techniques which will be useful 
           in the rest of the thesis.
           The second part (\cref{proposal, jcalccom, jcalcsem}) 
           constitutes my main contributions.
           I will propose  
           a modal type system that extends simple type theory
            (or, speaking from the logical side of \ac{CHI}, 
           intuitionistic propositional logic) with elements of
            justification logic and will argue about its computational significance. 
            More specifically, I will show  
           that the obtained calculus characterizes  certain 
           computational phenomena that abound in modern programming language semantics. 
           I will present full metatheoretic
           results obtained for this logic/ calculus utilizing techniques from the first part 
           and will provide proofs in the Appendix. 
           In the Appendix, the interested reader can find links to the active Github repo 
           that contains an implementation of  this calculus 
           (its term and type systems)
           in the metaprogramming framework \say{Makam} 
           as an additional  ``proof of concept'' result,  
           Finally, I conclude this work with a small ``outro'', Chapter~\ref{ext},
           where I informally show that the ideas underlying my contributions 
           can be extended in interesting ways.



