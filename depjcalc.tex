
\chapter{Jcalc and dependent typing}

A plausible reading of  G\"{o}del's incompleteness results (\cite{citeulike:713002}) 
 is that the notion of ``validity" diverges from that of ``truth within a specific theory": 
 given a theory that includes enough arithmetic, there are statements whose validity can only be 
 established in a theory of larger proof-strength.  This phenomenon can be shown even 
 with non-G\"{o}delian arguments in the relation e.g.  between ${\sf I\Delta_0}$ and ${\sf I\Sigma_1}$ 
 arithmetic \cite{parikh:existence}, ${\sf I\Sigma_1}$ and {\sf PA}, {\sf PA} and {\sf ZF},  etc. 
 \cite{Smith05anintroduction,Buss199879}. The very same issues arise in automated theorem proving. 
 A good example is given by type systems and interactive theorem provers (e.g. Coq, Agda) of the
  typed functional paradigm. In such systems, when termination of functions has to be secured, 
  one might need to invoke stronger proof principles. 
The need for reasoning about two kinds of proof objects within a type system is apparent most of
 all when one wants to establish non-admissibility results for a theory $T$ that can, 
 in contrast, be proved in some stronger $T'$. The type system, then, has to reconcile 
 the existence of  a proof object of some type $\phi$ in some $T'$  and a proof object of 
 type $\neg \exists s. Prov_{T}(s,\phi)$ that witnesses the non-provability of  $\phi$ (in $T$). 

In this work, we argue that the explicit modality of Justification Logic \cite{DBLP:conf/jelia/Artemov08} can be used to axiomatize relations between objects of two different calculi such as those mentioned above.  It is well known that the provability predicate can be axiomatized using a modality \cite{citeulike:214701}, \cite{ArtBek05HPL}. The Logic of Proofs {\sf LP} \cite{Art94APAL} goes further and provides explicit proof terms (\textit{proof polynomials}) to inhabit judgments on validity. By translating reasoning in Intuitionistic Propositional Calculus ({\sf IPC}) to classical proofs, {\sf LP} obtains a classical semantics for {\sf IPC} through a modality (inducing a {\sf BHK} semantics). In this paper we axiomatize the relation between the two kinds of proof objects explicitly, by creating a modal type theory that reasons about bindings or linking of objects from two calculi: a lower-level theory $T$, formulated as ${\sf IPC}$ with Church-style $\lambda$-terms representing intuitionistic proof objects; and a higher-level, possibly stronger and classical (co-)theory $T^\prime$ fixed as foundational, with \textit{justifications} expressing its proof objects. The axiomatization of such a (co-)theory follows directly the proof system of Justification Logic (here restricted to its applicative $K$-fragment) and is used to interpret classically (meaning \textit{truth-functionally}) the constructions of the intuitionistic natural deduction. The underlying principle of our linking system is as follows: $$constructive\ \  necessity= admissible \ \ validity = truth\  (in\  T) + validity\  (in\  T')$$ 

Necessity of a true (in $T$) proposition $P$ is, thus, sensitive to the existence of a proof (witnessed by a justification) of its intended interpretation within $T'$. We assume an interpretation function on types $Just$ that maps the type universe of $T$ into the type universe of $T'$.  We employ judgments of the kind $M:P$ (read as ``$M$ is a proof of type $P$ in $T$'') that represent truths in $T$ and  judgments of the kind $j:{\sf Just}\  P$ (to be read as "$j$ is a justification of the interpretation of $P$ in $T^\prime$") that represent truth in $T'$ (validity). Incorporating them, the principle can be rewritten in a judgmental fashion: $$M:P + j: {\sf Just}\  P \Rightarrow {\sf \Box^{j}}P\ true$$ Notice that the $\Box$-types are indexed by justifications (${\sf\Box^{j}}P$) being sensitive to the interpretation ($T^{\prime}$) chosen.   
To complete the picture we need canonical elements of ${\sf \Box^{j}}$-types. Naturally, witnesses of this kind are \textit{links} between proof objects from $T$ and $T'$ with corresponding types ($P$ and ${\sf Just \ P}$). For that reason we  introduce a \textit{linking witness} constructor {\sf $Link$}. This is how necessity is introduced: by proof-checking deductions of $T$ with deductions of $T'$,  we reason constructively about admissibility of valid (via $T'$) statements in $T$.
The principle thus becomes: 

$$M:P + j: {\sf Just}\   P \Rightarrow Link(M,j):{\sf \Box^{j}}P$$
We show how this principle is admissible in our system.

A possible application of the presented type theory can be a refined type system for programming languages with modular programming constructs or external function calls as we show in section \ref{sec:module}. In these kinds of languages (e.g. of the {\sf ML} family) a program or module can call for external definitions that are implemented elsewhere (in another module or, even in another language)\footnote{See \cite{Harper98programmingin}.}. We can read functions within $\Box$-types indexed by justifications as  linking  processes for such languages that perform  the mapping of well--typed constructs importing and using module signatures into their residual programs. By residual programs we mean programs where all instances of module types and  function calls are replaced by (i.e. \textit{linked} to) their actual implementations, which remain hidden in the module. We show with a real example how, with slight modifications, our type system can find a natural application in this setting. Here we focus on the type system itself and not on its operational semantics. 


The backbone of this work is the idea of representing the proof theoretic semantics for {\sf IPC} through modality that stems from \cite{Art01BSL},\cite{Art02CSLI}.  An operational approach to  modality related to this work can be found in \cite{Art95TR}. The modularity of {\sf LP}, i.e. its ability to realize other kinds of modal reasoning with proper changes in the axiomatization of proof polynomials, was shown with the development of the family of Justification Logics \cite{DBLP:conf/jelia/Artemov08}. This ability is easily seen to be preserved here. Our work incorporates the rich type system and modularity of Justification Logic within the proofs-as-programs doctrine. For that reason, we obtain an  extension of the Curry-Howard correspondence (\cite{Sorensen98lectureson}, \cite{citeulike:993095}) and adopt the judgmental approach of Intuitionistic Type Theory (\cite{inp:martin-loef79a}, \cite{martin-lof84:inttt}, \cite{citeulike:5251552}, \cite{citeulike:2310446}, \cite{awodey:kripke}). Our system borrows from other modal calculi developed  within the judgmental approach  (e.g. \cite{citeulike:5447115}, \cite{Goubault-Larrecq96oncomputational},\cite{Benaissa99logicalmodalities} and especially \cite{Bellin01extendedcurry-howard} for the modal logic {\sf K}). A main difference of our system with those systems, as well as with previous $\lambda$-calculi for {\sf LP} (\cite{AA00}, \cite{ArtBon07LFCS}) is that our type system  hosts a two-kinded typing relation for proof objects of corresponding formulae. It can be viewed as an attempt to add proof terms for validity judgments as presented in \cite{citeulike:5447115}.  The resulting type system adopts dependent typing (\cite{citeulike:4846}, \cite{Norell08dependentlytyped}) to relate the two kinds of proof objects with modality.  The construction of the type universe as well as of justificational terms draws a lot from ideas in \cite{Artemov:2012:OJL:2317882.2317912}  and from \cite{FittingManuscript-FITTLO}. Extending typed modal calculi with additional (contextual) terms of dependent typing can be also found in \cite{Nanevski:2008:CMT:1352582.1352591}. 
\section{A road map for the type system}
The present system can be viewed as a calculus of reasoning in three interleaving phases.
%
Firstly, reasoning about proof objects in the implicational fragment of an intuitionistic theory $T$ in absence of any metatheoretic assumptions of validity, introduced in Section \ref{sec:IPC}. This calculus is formalized by the turnstile $\Gamma\vdash_{\sf IPC}$\footnote{One could alternatively use an additional constant symbol {\sf null} and write ${\sf null};\Gamma\vdash_{\sf IPC}$ to denote reasoning  purely in $T$ and, thus, in absence of any metatheoretic environment.}  where $\Gamma$ contains assumptions on proofs of sentences in $T$. The underlying logic is intuitionistic, the system corresponding to the implicational fragment of  simply typed lambda calculus.
%
Secondly, reasoning with justifications, corresponding to reasoning  about proof objects in some fixed 
foundational system: the (co-)theory $T'$, %introduced in Section \ref{sec:J}. 
We suppose that $T'$ provides the intended semantics for the intuitionistic system $T$. 
The corresponding turnstile is $\Delta \vdash_{\sf J}$. Abstracting from any specific metatheory, 
all that matters  from a  purely logical point of view is that the theory of the interpretation 
should -- at least -- include as much logic as the implicational fragment of $T$ and 
it should satisfy some minimal conditions for the  provability predicate  of $T$. 

Finally, reasoning  about existence of \textit{links} between proof objects in the implicational fragment of \textit{both} axiomatic systems, introduced in Section \ref{sec:J-Calc}. This mode of reasoning is axiomatized within the full turnstile $\Delta;\Gamma\vdash_{\sf JC}$. The core of this system is  the $\Box$-Introduction rule, which allows to express constructive reasoning on linking existence. The idea is -- ignoring contextual reasoning for simplicity -- that linking a construction in $T$ with a justification of its corresponding type in $T'$ we obtain a proof of a constructive (or, admissible in $T$) validity. The rule in full (i.e. including contexts) corresponds to the construction of a link for a compound term based on existing link on its subterms.   
The full turnstile $\Gamma; \Delta\vdash$ is, hence, a modal logic that ``zips'' mutual reasoning between the two calculi. Within this framework we obtain a computational reading for justification logic restricted to $K$ modal reasoning. Before presenting this mutual reasoning at any arbitrary level of nesting (i.e. arbitrary modal types), we first introduce ${\sf JCalc_1}$ which is a restriction of the type universe up to ${\sf 1}$ level of $\Box$-nesting.

We fix a countable universe of propositions ($P_i$) that corresponds to  sentences of $T$. The elements of this universe can be inhabited either by constructions or justifications. We  will need, accordingly, two kinds of inhabitation relations for each proposition. We will be writing $M:\phi$ for a construction $M$ of type $\phi$ in $T$. We will be writing {$j: {\sf  Just}\  \phi$}  to express the fact that  {$j$} is a justification (proof in $T'$) of the proposition $\phi$. When there is no confusion we will be abbreviating this by {\sf $j:: \phi$}. A construction in $M:\phi$ in $T$ does not entail its necessity: to this aim, a corresponding justification {$j: {\sf  Just}\  \phi$} from $T'$ has to be obtained. Vice versa, the justification ($j$) of $\phi$ in $T'$ alone entails its validity but not its admissibility in $T$ (\textit{constructive  necessity}). This is expressed by the proposition -- type ${\sf \Box^{j}\phi}$. A construction of ${\sf \Box^{j}\phi}$ can be obtained only when the (weaker) theory $T$ actually ``responds" with a construction $M$ of the type $\phi$ to the valid fact $\phi$ known from $T'$ by deducing $j$. Hence, once (and only if) we have $j:: \phi$ then ${\sf\Box^{j}\phi}$ can be regarded as a well formed proposition. The  stronger theory might be able to judge about ${\sf\Box^{j}\phi}$ (given $j::\phi$) and prove e.g, $u::{\sf\Box^{j}\phi}$. In that case $T'$ ``knows"  that $\phi$ is admissible in $T$. In other words, when reasoning with justifications, the universe of types  is \textit{contextual}. To speak about  an admissible (or, constructive) necessity of a proposition we require the existence of a corresponding proof object $j$ in $T'$ that establishes its validity. 

\section{Reasoning without foundational assumptions: {\sf IPC}}\label{sec:IPC}

Reasoning about the implicational fragment of the constructive theory ($T$), without formulating provability statements, is done within the implicational fragment of the simply typed lambda calculus. We start by giving the grammar for the metavariable $\phi$ used in the rules.

\begin{displaymath}
\phi:= P_i | \phi \rightarrow \phi
\end{displaymath}
%
The calculus is presented by introducing: the universe of types {$\sf Prop_0$}; rules for constructing well-formed contexts of simple propositional assumptions $\Gamma_0$; the rules governing $\vdash_{{\sf IPC}}$.


\begin{mathpar}
\inferrule*[right=Atom$_0$] { } {P_i \in {\sf Prop_0}}
\and
\inferrule*[right=Impl$_0$] {{\phi_1 \in {\sf Prop_0 }}\\ {\phi_2 \in {\sf Prop_0}}} {\phi_1\rightarrow\phi_2\in {\sf Prop_0}}
\end{mathpar}



\begin{mathpar}
\inferrule*[right=Nil$_0$] { } {\Turn {\sf nil} {\sf wf}}
\and
\inferrule*[right=$\Gamma_0$-Exp] {{\Turn {\Gamma_0} {\sf wf} } \\ 
{\phi \in {\sf Prop_0}}} {\Turn {\Gamma_0 , x:\phi} {\sf wf}}
\end{mathpar}


\begin{mathpar}
\inferrule*[right=$\Gamma$-Refl] {{\Turn {\Gamma_0} {\sf wf}}\\ {x:P_i \in \Gamma_0}}{\Turn {\Gamma_0} {x:P_i}}
\end{mathpar}
\begin{mathpar}
\inferrule*[right=$\rightarrow$I] {\Turn {\Gamma_0, x:\phi_1} {M:\phi_2}} {\Turn {\Gamma_0} {\lambda  x:\phi_1 . \   M : \phi_1\rightarrow \phi_2}}
\and
\inferrule*[right=$\rightarrow$E] {\Turn {\Gamma_0} {M:\phi_1\rightarrow\phi_2}\\{\Turn {\Gamma_0} {M':\phi_1}}} {\Turn {\Gamma_0} {  (M  M'):\phi_2}}
\end{mathpar}

\section{Reasoning in the Presence of Foundations: A calculus of Justifications {\sf J}}\label{sec:J}

Reasoning in the presence of minimal foundations corresponds  to reasoning on the existence of  proof objects in the foundational theory  $T'$. The minimal foundational assumptions from the logical point of view is that $T'$ ``knows" at least as much logic as $T$ does. 
The more non-logical axioms in $T$, the more the specifications $T'$ should satisfy (one needs stronger foundations to justify stronger theories). Abstracting from any particular $T$ and $T'$, and assuming only that $T$ incorporates minimal logic, the  specifications 
about existence of proofs in  $T'$ are:

\begin{itemize}
\item{to have ``enough" types to provide -- at least -- an intended interpretation of every type $\phi$ of $T$ to a unique type ${\sf Just}\ \phi$. In other words a subset of the types of $T'$ should serve as interpretations of types in $T$;}
\item{to have -- at least -- proof objects for all the instances of the axiomatic characterization of the {\sf IPC} fragment described above;\footnote {If we extend our fragment we should extend our specifications accordingly but this can be easily done directly as in full justification logic. We choose to remain within this fragment for economy of presentation.}}
\item{to include some modus ponens rule which translates as: the existence of  proof objects of types $\sf Just \ (\phi\rightarrow \psi)$ and  of type ${\sf Just\  \phi}$ in $T'$ should imply the existence of a proof object of the type ${\sf Just\  \phi}$. }
\end{itemize}

\subsection{Minimal Justification Logic {\sf J-\sf Calc${_1}$}}\label{subsec:J-Calc1}

Under these minimal requirements, we develop a minimal justification logic that is able to realize modal reasoning as reasoning on the existence of links between proofs of $T$ and $T'$. We first realize modal reasoning restricted to formulae of degree (i.e. level of $\Box$-nesting) $1$. Such a calculus will be used as a base to build a full modal calculus with justifications for formulae of arbitrary degree.  Here is the grammar for the metavariables appearing below:
\begin{flalign*}
\phi :=  & P_i | {\sf\Box^{j}}\phi| \phi_1 \rightarrow\phi_2  \\
j:= & s_i| C| j_1*j_2  \\
t:=& x_i| \lambda x_i:\phi. t| Js::\phi.t\\
C:= & {\sf K}[\phi_1,\phi_2]| {\sf S}[\phi_1,\phi_2,\phi_3]| C_1*C_2 \\
{\sf \pi}:= & \Pi s::\phi_1. \  \phi_2| \Pi s::\phi_1.\ {\sf \pi} \\
{\sf T} :=& \phi|{\sf Just}\ \phi| \pi\\
s:= & s_i  \\
x:=&x_i\\
\end{flalign*}

\subsubsection{\sf Reasoning on minimal foundations ${\sf J_0}$}\label{subsec:J0} 

Reasoning about such a minimal metatheory is axiomatized in its own turnstile ($\vdash_{J_0}$).\footnote{ This is the part of the calculus that corresponds directly to the algebra of justifications restricted to the applicative fragment.} Henceforth, judgments on the justificational type universe of {\sf J$_0$} (corresponding to formualae in the (co-)theory $T'$) together with ${\sf wf}$ predicate for  $\Delta_0$ contexts go as follows: 

\begin{mathpar}
\inferrule*[right=Nil] { } {{\sf nil}\vdash_{\sf J_0} {\sf wf}}
\and
\inferrule*[Right=Simple] {{\Turnj   {\sf wf}}\\{\Turnj {\phi \in {\sf Prop_0}} {\sf }}}{\Turnj {} {{\sf Just}\  \phi \in {\sf jtype_0}}}
\and
\inferrule*[right=$\Delta_0$-App] {{\Turnj {{ \sf Just}\ \phi \in {\sf jtype_0}}}\\{s \not \in \Delta_0}} {\Delta_0, s::\phi\vdash_{\sf J_0} {\sf wf}}
\and
\inferrule*[right=$\Delta_0$-Refl] {{\Turnj     {\sf wf}} \\{s::\phi \in \Delta}} {\Turnj {s::\phi}}
\end{mathpar}
%
We add logical constants to satisfy the requirement that {\sf J$_{0}$} includes an axiomatic characterization of -- at least -- a fragment of ${\sf IPC}$. Following justification logic,  we  define a signature of polymorphic constructors including {$\sf K$}, {$\sf S$} from combinatory logic. The values of those constructors are axiomatic constants  that witness existence of proofs in $T'$ of all instances of the corresponding logical validities. This axiomatic characterization of intuitionistic logic in  {\sf J$_{0}$} together with  rule scheme {$\sf Times$} (\textit{applicativity of justifications}) satisfy the minimal requirement for $T'$ to reason logically.  

\begin{mathpar}
[Right={\sf K}]  {\Turnj {{\sf Just} \ \ \phi_1\rightarrow\phi_2\rightarrow\phi_1 \in {\sf jtype_0}}}   {\Turnj  {{\sf K}[\phi_1,\phi_2]:: \phi_1\rightarrow\phi_2\rightarrow\phi_1}}
\and
\inferrule*[Right={\sf S}]  {\Turnj {{\sf Just} \ \ (\phi_1\rightarrow \phi_2\rightarrow \phi_3)\rightarrow (\phi_1\rightarrow \phi_2)\rightarrow (\phi_1\rightarrow \phi_3)\in {\sf jtype_0}}}  {\Turnj  {{\sf S}[\phi_1,\phi_2,\phi_3]:: (\phi_1\rightarrow \phi_2\rightarrow \phi_3)\rightarrow (\phi_1\rightarrow \phi_2)\rightarrow (\phi_1\rightarrow \phi_3)}}
\end{mathpar}
\begin{mathpar}
\inferrule*[Right={\sf Times}]  {{\Turnj  { j_2 :: \phi_1\rightarrow \phi_2}}\\  {\Turnj { j_1::\phi_1}}} {\Turnj {j_2*j_1::\phi_2}}
\end{mathpar}
%







\subsubsection{Zipping: {\sf J-Calc}$_1={\sf IPC}+ {\sf J}_0+\Box{\sf-Intro}$}\label{sec:jcalc1}
In this section we introduce {\sf J-Calc$_1$} for reasoning on the existence of  links i.e. constructions that witness the existence of proofs both in {\sf IPC} ($T$) and {\sf $J_0$} ($T'$). By constructing a link we have a proof of a constructive necessity of a formula, showing that it is true and valid. Links have types of the form ${\sf\Box^{j}\phi}$ where $j$ is a justification of the appropriate type. {\sf J-Calc$_1$} realizes modal logic theoremhood in $K$ up to degree $1$ (i.e. formulae where its subformula includes up to $1$ level of $\Box$). 

We start by importing well-formedness judgments for contexts and justificational types ($\Delta_0$Wf, JustWf respectively), and for the Prop$_{1}$ universe and its contexts: 

\begin{mathpar}
\inferrule*[right=$\Delta_{0}$Wf]  {\Turnj  {\sf wf}}  {\TurnTT{\sf nil} {\sf wf}}
\and
\inferrule*[right=Just$_{0}$Wf] { {\TurnTT {\Gamma_1} {\sf wf}} \\{\Turnj  {j ::  \phi}}}  {\TurnTT {\Gamma_1} { {j:: \phi}}}
\and
\inferrule*[right=Prop$_1$-Intro] {  {\phi \in {\sf Prop_0 }} \\ {\TurnTT {\Gamma_1} { j::\phi}}} {\TurnTT {\Gamma_1} {\Box^{j}\phi \in {\sf Prop_1}}}
\and
\inferrule*[right=$\Gamma_1$-App] { {\TurnTT{\Gamma_1} {\phi \in \sf \{Prop_0,Prop_1\}}}  \\ {x\not\in\Gamma_1}} {\TurnTT {\Gamma_1, x:\phi} { {\sf wf}}}
\end{mathpar}
\bigskip

From justifications of formulas in ${\sf Prop_0}$, we can reason about their admissibility in $T$. Hence, $\Gamma_1$ might include assumptions from the sorts ${\sf Prop_0}$ and ${\sf Prop_1}$. For the inhabitation of ${\sf Prop_0, Prop_1}$, we first accumulate intuitionistic reasoning extended to the new type universe (${\sf Prop_1}$), adapting the rules from Section \ref{sec:IPC}:
\bigskip

\begin{mathpar}
\inferrule*[right=$\Gamma_1$-Refl] {{\TurnTT  {\Gamma_1} {\sf wf}}\\ {x:\phi \in \Gamma_1}} {\TurnTT {\Gamma_1} {x:\phi}}

\and
\inferrule*[right=$\rightarrow$I] {\TurnTT {\Gamma_1, x:\phi_1} {M:\phi_2}} {\TurnTT {\Gamma_1} {\lambda  x:\phi_1 . \   M : \phi_1\rightarrow \phi_2}}
\and
\inferrule*[right=$\rightarrow$E] {\TurnTT {\Gamma_1} {M:\phi_1\rightarrow\phi_2}\\{\TurnTT {\Gamma_1} {M':\phi_1}}} {\TurnTT {\Gamma} {  (M  M'):\phi_2}}
\end{mathpar}
%
For relating the two calculi, a lifting rule is formulated for turning strictly ${\sf Prop_0}$ judgments to judgments on proof links (${\sf Prop_1}$). In the rule,  the $\downharpoonright$-operator ensures that  context list $\downharpoonright\Gamma$ includes assumptions strictly in ${\sf Prop_0}$. 
The operator $\downharpoonright$ can be viewed as the opposite of \textit{lift} operation applied on context lists  erasing one level of boxed assumptions at the top level as described below.
 \begin{align}
\nonumber \downharpoonright\Gamma\  :=\textbf{match $\Gamma $\ with} \\
&\nonumber   {\sf nil} \Rightarrow {\sf  nil}\\
&\nonumber|\ \Gamma', x_i^{\prime}:\Box^{j} \phi_i\Rightarrow\ \downharpoonright \Gamma' ,\  x_i:\phi_i\\
&\nonumber|{\Gamma',\_}\Rightarrow {\downharpoonright\Gamma'} 
\end{align}
A corresponding iterative \textit{let-binding} construct ($let^{*}$) is introduced simultaneously with the context lifting. The purpose of the iterative let binding is to extract the target(s) ($T'$ terms) of existing links on subterms ($x_1\ldots x_n$) of some composite term $M$ in $T$ and compose them to the target of the whole term $M$ creating its residual. We show the operation of this construct in the example from section \ref{sec:module}.
 
\begin{align}
\nonumber let^{*}\ \Gamma\  :=\\ 
\nonumber\textbf{match $\Gamma $\ with} \\
&\nonumber   {\sf nil} \Rightarrow {let\  ()= ()}\\
&\nonumber|\ \Gamma', x_i^{\prime}:\Box^{j} \phi_i\Rightarrow\ (let^{*}\ \Gamma')  \ in\  let \ link  (x_i,j_i)=x_i^{\prime}\\
&\nonumber|{\Gamma',\_}\Rightarrow {let^{*}\ \Gamma'} 
\end{align}

The $\Box$-Introduction rule goes as follows:
{\begin{mathpar}
\inferrule*[right=$\Box$-Intro]{{   ;\downharpoonright \Gamma_1\vdash_{\sf JC_1} M:\phi}\\
{\Delta_0;\Gamma_1\vdash_{\sf JC_1} {j::\phi}}\\
%{\Delta_0;\Gamma_1\vdash_{\sf JC_1} {\sf wf}}
}
{\Delta_0;\Gamma_1\vdash_{\sf JC_1} (let^{*}\   \Gamma) \ in \  link  \ (M,j) : \Box^{j}\phi}
\end{mathpar}}
%

Finally, under empty $\Gamma_1$, we are permitting abstraction from a non-empty $\Delta_0$. The resulting abstractions ($J-$terms), as we will see, are the inhabitants of modal types and correspond to linking processes. Their typing is, naturally, of $\Pi$-kind since the typing of a link is sensitive to its target code. We introduce $\Pi$-formation and inhabitation rules:
\bigskip

\begin{mathpar}
\inferrule*[right=$\Pi$ type$_0$] { {\Delta_0,s::\phi_1;  \vdash_{\sf JC_1}\phi_2 \in \sf \{Prop_0,Prop_1\}}}   { {\Delta_0;  \vdash_{\sf JC_1}\Pi s::\phi_1.\phi_2 \in \Pi}}
\and
\inferrule*[right=$\Pi$ type$_1$] { {\Delta_0,s::\phi_1;  \vdash_{ \sf JC_1}\pi \in \Pi}}   { {\Delta_0;  \vdash_{\sf JC_1}\Pi s::\phi_1.\pi \in \Pi}}
\end{mathpar}
{\begin{mathpar}
\inferrule*[right=$\Pi$-Intro]{  \Delta_0,s::\phi ;\vdash_{\sf JC_1} t:{\sf T}}
{\Delta_0;\vdash_{\sf JC_1} {J s::\phi.\ t: \Pi s::\phi. {\sf T}}}
\and
\inferrule*[right=$\Pi$-Elim]{{  \Delta_0 ;\vdash_{\sf JC_1} t:{\Pi s::\phi. {\sf T}}}\\{\Delta_0;
\vdash_{\sf JC_1}j::\phi}}
{\Delta_0;\vdash_{\sf JC_1} {\ (t \ j): {\sf T[s:=j]}}}
\end{mathpar}} 

\section{The Full Calculus: J-Calc}\label{sec:J-Calc}

{\sf J-Calc$_1$} motivates the generalization to modal reasoning of arbitrary nesting: {{\sf J-Calc}. To allow such generalization, we need justifications of types of the form ${\sf Just\  \Box^{j}\phi}$. Let us revise: If $\phi$ is a proposition (or, a sentence in the language of $T$), then ${\sf Just\ \phi}$ corresponds to the intended interpetation of $\phi$ in some (co-)theory $T'$. In {\sf J-Calc$_1$} we could reason logically about the constructive admissibility of (valid according to $T'$) facts of $T$. The existence of a link of a proof in $T$ with an existing proof of the same type in $T'$ would lead to constructions of a type of the form $\Box^{j}\phi$ with $\phi$ a simple type. To get modal theoremhood of degree ${\sf 2}$ or more we have to assume that $T'$ can express the existence of such links in itself. That is to say that $T'$ can express the provability predicates both of $T$ \textit{and} of itself. Hence, supposing that $j::\phi$, we can read a justification term of type ${{\sf Just}\  \Box^{\sf j}\phi}$ as a witness of a proof in $T'$ of the fact $\exists x. Proof_T(x, \underline{\phi}) \wedge \exists x. Proof_{T'}(x, \  \underline{{\sf Just\  \phi}}) $ expressed in $T'$. 
We will specify which of those types $T'$ is expected to \textit{capture} by introducing additional appropriate constants. Having this kind of justifications we can obtain ${\sf Prop_i}$ for any finite $i$ as slices of a type universe in a mutual inductive construction. Schematically: $ {\sf Prop_0\Rightarrow Just \ Prop_0\Rightarrow \ Prop_1 \Rightarrow Just\ Prop_1}$ and so on. This way we obtain full minimal  justification logic. As different kinds of judgments are kept separated by the different typing relations, we do not need to provide distinct calculi as we did for {\sf J-Calc$_1$} but we provide one ``zipped" calculus directly. \footnote {In fact, adjoining $\Gamma$ contexts when reasoning within justifications is pure weakening so we could have kept those judgments separated in a single--context $\vdash$ relation. We gain something though: we can squeeze two premises ($\Delta\vdash j::\phi$, $\Delta;\Gamma\vdash{\sf wf}$) to a single one ($\Delta;\Gamma\vdash j::\phi$).}

\subsection{Justificational (Validity) Judgments}
\label{sec:propjtype1}
The justificational type system has to include: judgments on the wellformedness of contexts ({$\sf wf$});\footnote{ Analogous treatments of judgments on the validity of contexts can be found e.g. in \cite{Norell08dependentlytyped}.} judgments on what $T'$  can reason about ($\sf jtype$)  under the requirement that it is a metatheory of $T$; judgments on the construction of the justificational type universe ({\sf jtype}) and minimal requirements about its inhabitation (i.e, \textit{a  minimal signature of  logical constants}). The grammar of terms is the same as in section \ref{subsec:J-Calc1}, the difference now is that the restrictions on the $Prop$ universe are dropped. 

%
We introduce progressively: formation rules for {\sf Prop}; the formation rule for {\sf jtype}; rules to build well-formed contexts of propositions and justifications (where we will be abbreviating using the following equational rule: 
${\sf nil}, s_1::\phi_1, s_2::\phi_2, \ldots =^{def} s_1::\phi_1, s_2::\phi_2, \ldots $
).


\begin{mathpar}
\inferrule*[right=NIL]
	{ }
	{\Turnjc {\sf nil}{\sf nil}{\sf wf} }
\and
\inferrule*[right=Atom] { \Turnjc {\Delta} {\Gamma} {\sf wf}}  { \Turnjc {\Delta} {\Gamma} {P_i \in {\sf Prop}}} 

\and
\inferrule*[right=Impl] {{\Turnjc {\Delta} {\Gamma} \phi_1 \in {\sf Prop}}\\ {\Turnjc \Delta {\Gamma} \phi_2 \in {\sf Prop}}} {\Turnjc {\Delta} {\Gamma}\phi_1\rightarrow\phi_2\in {\sf  Prop}}
\and
\inferrule*[right=Box] {{\Turnjc  {\Delta} {\Gamma} {{  j::\phi}}}}  {\Turnjc {\Delta} {\Gamma}{\Box^{j} \phi} \in {\sf Prop}}
\and
\inferrule*[right=Jtype] {\Turnjc   {\Delta} {\Gamma}{\phi \in {\sf Prop}}}{\Turnjc {\Delta} {\Gamma}{{\sf Just}\  \phi \in {\sf jtype}}}
\and
\inferrule*[right=$\Delta$-App]   {{\Turnjc {\Delta} {\Gamma} {{\sf Just \ \phi}\in {\sf jtype}}} \\{s \not \in \Delta }} {\Turnjc {\Delta, s:: \phi}{\Gamma} {\sf wf}}
\and
\inferrule*[right=$\Gamma$-App] { {\Turnjc {\Delta}{\Gamma} {\phi \in \sf Prop}}\\  {x\not\in\Gamma}} {\TurnT {\Gamma, x:\phi} { {\sf wf}}}
\end{mathpar}
%


\subsubsection{${\sf Prop}$ Inhabitation}
Here is the first part of logical propositional reasoning of the system.

\begin{mathpar}
\inferrule*[right=$\Gamma$-Refl] {{\Turnjc {\Delta} {\Gamma} {\sf wf}}\\ {x:\phi \in \Gamma}} {\Turnjc {\Delta}{\Gamma} {x:\phi}}

\end{mathpar}
\begin{mathpar}
\inferrule*[right=$\rightarrow$I] {\Turnjc {\Delta} {\Gamma, x:\phi_1} {M:\phi_2}} {\Turnjc {\Delta} {\Gamma} {\lambda  x:\phi_1 . \   M : \phi_1\rightarrow \phi_2}}
\and
\inferrule*[right=$\rightarrow$E] {\Turnjc {\Delta} {\Gamma} {M:\phi_1\rightarrow\phi_2}\\{\Turnjc {\Delta}{\Gamma} {M':\phi_1}}} {\Turnjc {\Delta}{\Gamma} {  (M  M'):\phi_2}}
\end{mathpar}


\subsubsection{${\sf jtype}$ Inhabitation}




Now we move to the core of the system. In the judgments below we provide the constructions of canonical elements of justificational types (${\sf jtype}$). The judgments reflect  the minimal requirements for $T'$ to be a metatheory of some $T$ as presented  in Section \ref{subsec:J0} together with specifications on internalizing proof links reasoning in itself. More specifically, we demand that $T'$ can \textit{capture} reasoning on links (between proof objects of $T$ and itself) \textit {within} itself and also, internalize modus ponens of $T$.  To capture these provability conditions we add the constant constructors ${\sf !}$ (\textit{bang}) and  ${\sf Kappa}$. Although introduction of links is axiomatized in the next section, the judgments concerning the ${\sf !}$ and ${\sf Kappa}$ constructors should be viewed in conjunction with $\Box-Intro$. They witness the fact that $T'$ internalizes modus ponens (of $T$)  and linking existence  (again of $T$).  


\begin{mathpar}
\inferrule*[right=K]  {\Turnjc  {\Delta} {\Gamma} {{\sf Just} \ \ \phi_1\rightarrow\phi_2\rightarrow\phi_1 \in {\sf jtype}}}   {\Turnjc {\Delta} {\Gamma}{{\sf K}[\phi_1,\phi_2]:: \phi_1\rightarrow\phi_2\rightarrow\phi_1}}
\and
\inferrule*[right=S]  {\Turnjc {\Delta }{\Gamma} {{\sf Just} \ \ (\phi_1\rightarrow \phi_2\rightarrow \phi_3)\rightarrow (\phi_1\rightarrow \phi_2)\rightarrow (\phi_1\rightarrow \phi_3)\in {\sf jtype}}}  {\Turnjc {\Delta} {\Gamma} {{\sf S}[\phi_1,\phi_2,\phi_3]:: (\phi_1\rightarrow \phi_2\rightarrow \phi_3)\rightarrow (\phi_1\rightarrow \phi_2)\rightarrow (\phi_1\rightarrow \phi_3)}}
\and
\inferrule*[right=Times]  {{\Turnjc {\Delta } {\Gamma} { j_2 :: \phi_1\rightarrow \phi_2}}\\  {\Turnjc {\Delta} {\Gamma}  { j_1::\phi_1}}} {\TurnTwo{\Delta} {j_2*j_1::\phi_2}}
\and
\inferrule*[right=Bang]  {\Turnjc {\Delta }{\sf nil} { M: \Box^{\sf C}\phi}} {\Turnjc{\Delta}{\Gamma} {! C::{\sf \Box^{C}}\phi}}
\and
\inferrule*[right=Kappa] {{\Turnjc {\Delta} {\Gamma} {\sf Just}\ {\Box^{ \sf j'}\phi_1\in {\sf jtype} }}\\ {\Turnjc {\Delta }{\Gamma} {{\sf Just}\ \ \Box^{\sf j}(\phi_1 \rightarrow \phi_2)\in {\sf jtype}}}}
{\Turnjc {\Delta}{\Gamma} { {\sf Kappa} [j, j',\phi_1,\phi_2]: :   \Box^{ \sf j}(\phi_1 \rightarrow \phi_2)\rightarrow \Box^{\sf  j'}\phi_1\rightarrow \Box^{ \sf j*j'} \phi_2 }}
\end{mathpar}




\subsection{Proof Links}\label{sec:propjtype2}

Our next task is to formulate the main rule for the $K$ modality as a lifting rule for going from reasoning about constructions to reasoning about admissibility of validities via proof linking. 
To reflect the modal axiom $K$ in Natural Deduction we have to obtain a rule that reflects the following provability principle: 

\begin{mathpar}
\inferrule*[right=$\Box$-Intro] {{\phi_1\  {\sf true}, \ldots,  \phi_n\  {\sf true} \vdash \phi\  {\sf true}} \\{\phi_1\  {\sf valid} , \ldots,  \phi_n\ {\sf valid} \vdash \phi\ {\sf valid}}}
{\Box \phi_1\ {\sf true},  \ldots,  \Box \phi_n \ {\sf true}, \ldots \vdash \Box\phi \ {\sf true}} 
\end{mathpar}

We proceed with giving inhabitants analogously to what was explained in Section \ref{sec:jcalc1}:\footnote{We prefer this to the mouthful but equivalent:
\begin{mathpar}
\inferrule*[right=$\Box$-Intro]
{
{\Delta; x_1:\phi_1, \ldots,  x_i:\phi_i \  \ as \ \Gamma\vdash M:\phi}\\
{\forall \phi_i \in \Gamma. \ \Delta';{\sf nil}\vdash  j_i::\phi_i} 
\\
{\Delta';{\sf nil}\vdash  j::\phi} \\
{\Delta';x_1:\Box^{j_1}\phi_i, \ldots, \Box^{j_i}\phi_i\vdash {\sf wf}}
}
{\Delta';x_1:\Box^{j_1}\phi_i, \ldots, \Box^{j_i}\phi_i\vdash  
JBox \ j: \Box^{\sf j}\phi}
\end{mathpar}

}
\begin{mathpar}
\inferrule*[right=$\Box$-Intro]
{
{\Delta;   \downharpoonright \Gamma\vdash_{\sf JC} M:\phi}\\
{\Delta;\Gamma\vdash_{\sf JC}j::\phi}
}
{\Delta;\Gamma\vdash_{\sf JC} 
(let^{*}\   \Gamma) \ in \  link  \ (M,j): \Box^{ j}\phi}
\end{mathpar}



Finally, abstraction from $\Delta$ contexts over empty $\Gamma$ contexts applies in the extended type universe:

{\begin{mathpar}
\inferrule*[right=$\Pi$-Intro]{  \Delta,s::\phi ;\vdash_{\sf JC} t:{\sf T}}
{\Delta;\vdash_{\sf JC} {J s::\phi.\ t: \Pi s::\phi. {\sf T}}}
\and
\inferrule*[right=$\Pi$-Elim]{{  \Delta ;\vdash_{\sf JC} t:{\Pi s::\phi. {\sf T}}}\\{\Delta_0;
\vdash_{\sf JC}j::\phi}}
{\Delta;\vdash_{\sf JC} {\ (t \ j): {\sf T[s:=j]}}}
\end{mathpar}} 




\section{Further Results and Conclusions}\label{sec:Meta}

Standard meta-theoretical results can be proven for  {\sf J-Calc}. We just mention here that the iterative $let$ operator satisfies standard commutativity with the substitution rule for justifications and that structural rules can be proven. We will be skipping the index in $\vdash_{\sf JC}$.

\begin{theorem}[Weakening]
{\sf J-Calc} satisfies Weakening in both modes of reasoning:

\begin{enumerate}
\item If $\Delta; {\sf nil}\vdash j::\phi$, and $\Delta; {\Gamma}\vdash{\sf wf} $ then, $\Delta; \Gamma \vdash j::\phi$.
\item If $\Delta; \Gamma \vdash j::\phi$, then $\Delta, s::\phi'; \Gamma \vdash j::\phi$, with $s$ fresh.
\item If $\Delta; {\Gamma} \vdash M:\phi$, then $\Delta; \Gamma, x\!:\!\phi' \vdash M:\phi$, with $x$ fresh.
\end{enumerate}
\end{theorem}
\begin{proof}
For all items by structural induction on the derivation trees  of the two kinds of constructions. The proof of the first is vacuous since $\Gamma$ contexts are irrelevant in justification formation. As a result, its inverse can also be shown.
\end{proof}
\begin{theorem}[Contraction]
{\sf J-Calc} satisfies Contraction:

\begin{enumerate}
\item If $\Delta, s::\phi, t::\phi; {\sf nil} \vdash j::\phi'$, then $\Delta, u::\phi; {\sf nil} \vdash j[s\equiv t/u]::\phi'$.
\item If $\Delta, s::\phi, t::\phi; \Gamma\vdash {\sf wf}$, then, $\Delta,u::\phi; \Gamma[s\equiv t/u]\vdash {\sf wf}$.
\item If $\Delta, s::\phi, t::\phi; \Gamma\vdash M:\phi'$, then, $\Delta,u::\phi; \Gamma[s\equiv t/u]\vdash M[s\equiv t/u]:\phi'[s\equiv t/u]$.
\item If $\Delta; \Gamma, x:\phi, y:\phi \vdash M:\phi'$, then $\Delta; \Gamma, z:\phi \vdash M[x\equiv y/z]:\phi'$.
\end{enumerate}
\end{theorem}
\begin{proof}
First item by structural induction on the derivation trees of justifications (validity judgments). Note, as mentioned in the previous theorem, that it can be shown for arbitrary $\Gamma$. For the second, nested induction on the structure of context $\Gamma$ (treated as list) and the complexity of formulas. Vacuously in the {\sf nil} case. For the non-empty case: case analysis on the complexity of the head formula using the inductive hypothesis on the tail. Cases of interest are with $\Box^{\sf s}\phi$ or $\Box^{\sf t}\phi$ as subformulae. Use the previous item and judgments for ${\sf wf }$ contexts. For the third and the fourth, again by structural induction on the derivation.
\end{proof}

In a similar fashion we can show the more general:

\begin{theorem}[Preservations of Types under Substitution]
{\sf J-Calc} preserves types under substitution and simultaneous substitution:
\begin{enumerate}
\item {If $\Delta;\Gamma,x:\phi\vdash t:{\sf T}$, and $\Delta;\Gamma\vdash M :\phi$ then $\Delta;\Gamma\vdash t[x/M]:{\sf T}$}
\item{
 If $\Delta, s::\phi,\Delta';\Gamma\vdash t:{\sf T}$, and $\Delta;\vdash j::\phi$ then $\Delta,\Delta'[s/j];\Gamma[s/j]\vdash t[s/j]:{\sf T}[s/j]$}
\end{enumerate}
\end{theorem}

We additionally mention that the calculus satisfies \textit{permutation} for both contexts $\Delta$ and $\Gamma$ with the restriction that the permutations in $\Delta$ should not break the chain of dependencies. Lastly, we mention here that under standard ${let}$-binding evaluation and application as $\beta$-reduction within a dependently typed framework, a small step operational semantics has been developed and progress and preservation can be shown.

For future work, we plan to extend the computational relevance of the full calculus ({\sf JCalc}) by establishing its connection with higher-order module systems (e.g. where module signatures can refer to other module signatures which, in turn, are implemented by a third module). Linking processes in such systems would utilize our type system in full. Cut-elimination results are currently under development.

