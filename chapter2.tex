\chapter{Typed lambda calculus}\label{lambda}
\section{From intuitionistic provability to  proof trees}
\vocab{IPL} can be viewed as a declarative axiomatization of proof constructs. Take the introduction rule for conjunction as an example: 
\begin{mathpar}
	\inferrule*[right=$\wedge$I] {\Turnsi {\Gamma} {A\true}\\
	{\Turnsi {\Gamma} {B \true}}} {\Turnsi {\Gamma} 
	{  A \wedge B \true}}
\end{mathpar}

The rule says, ``given the existence a proof of $A$  and a proof of $B$ from assumptions $\Gamma$, there exists a proof of $A\wedge B$ from assumptions $\Gamma$ at hand ".

We used the description ``declarative" because in this format \vocab{IPL} sequents $\Gamma\vdash \true $ do not describe how such existentials are realized. It is in essence a logic of ``proof relevant truth" but it does not involve the proofs themselves as first class objects. 

An alternative presentation is to explicate proof constructs by directly providing a system of ``proof trees". Such an approach was actually championed in Gentzen's natural deduction systems and is the necessary move to obtain proof calculi. 
Once we have  explicit  proof objects (either as trees, or as we will see, as terms) the system is enriched with equality principles involving such objects. Such rules give computational value (``proof dynamics") 
to the constructs  and  drive the idea of  ``Curry--Howard Isomorphism" 
and its extensions. We will provide such a  formulation in proof trees of
 judgments together with the equality rules on trees, 
 essentially following Gentzen. 
 
 Proof trees of judgments have the following shape:

\begin{mathpar}
\inferrule*[vdots=1.5em]{}{ J_1,\ldots,  J_i}
\end{mathpar}
\begin{mathpar}
\inferrule*[]{}{J}
\end{mathpar}
We focus on judgments $J$ of the form ${A \true}$.
Here are the the rules for constructing proof trees with labeled assumptions\footnote{Strictly speaking the constructs are directed acyclic graphs and not \textit{trees} 
since assumptions with the same label are bound and substitutable together but we will be cavalier with such a detail}.
\begin{mathpar}
\begin{array}[b]{c}{ x_1:A_1 \true,\ldots,  x_i:A_i\true}\\{\vdots}\\{A_{j\in 1\dots i} \true}
\end{array}
\and
\begin{array}[b]{c}{ x_1:A_1 \true, \ldots,   x_i:A_i\true}\\{\vdots}\\{\top\true}
\end{array}
\end{mathpar}

\begin{mathpar}
	\inferrule[]{{\begin{array}[b]{c} {\mathcal{D}} \\ A\true  \end{array}}\\ {\begin{array}[b]{c} {\mathcal{E}} \\ B\true  \end{array}}}{A \wedge B \true}
	
\end{mathpar}
\begin{mathpar}
	\inferrule[]{{\begin{array}[b]{c} {\mathcal{D}} \\ A\wedge B\true  \end{array}} }{A \true}
	\and
	\inferrule[]{{\begin{array}[b]{c} {\mathcal{D}} \\ A\wedge B\true  \end{array}} }{B \true}
\end{mathpar}

\begin{mathpar}
\inferrule[]{{\begin{array}[b]{c} \overline{x:A}\\ {\mathcal{D}} \\ B \true  \end{array}} }{A\supset B \true}
\and
\inferrule[]{{\begin{array}[b]{c} {\mathcal{D}} \\ A\supset B\true  \end{array}}\\ {\begin{array}[b]{c} {\mathcal{E}} \\ A\true  \end{array}}}{B  \true}
	
\end{mathpar}


\begin{mathpar}
	\inferrule[]{{\begin{array}[b]{c} {\mathcal{D}} \\ A \true \end{array}} }{A\vee B \true}
	\and
	\inferrule[]{{\begin{array}[b]{c} {\mathcal{D}} \\ B\true  \end{array}} }{A\vee B \true}
\end{mathpar}
\begin{mathpar}
	
\end{mathpar}
\begin{mathpar}
	\inferrule[]{{\begin{array}[b]{c}  {\mathcal{D}} \\ A\vee B \true \end{array}} \\ {\begin{array}[b]{c} {A\true}\\ {\mathcal{E}} \\ C \true \end{array}}\\
	{\begin{array}[b]{c} {B\true}\\ {\mathcal{F}} \\ C \true \end{array}		 }}{C\true}
\end{mathpar}

\begin{mathpar}
	\inferrule[]{
	{\begin{array}[b]{c}  {\mathcal{D}} \\ \bot \true \end{array}}}{C \true}
\end{mathpar}
%\begin{mathpar}
%\inferrule*[]{\PrTri{D}} {\PrTri{E} }
		
%\end{mathpar}
%\begin{mathpar}
%{\inferrule*[]{}{ \inferrule*[]	{\inferrule*[]{}{{D} \\ {E}}\\\\
			%\inferrule*[]{}{\    A\\ \ \qquad %\llbracket   A\rrbracket}}{\Box   A }}}
%\end{mathpar}
\subsection{Properties of Intuitionistic Entailment Redux}
Proof trees by their nature satisfy the properties of entailment in \ref{ssec:entail}. 
We will not bother with reflection and contraction. The first is trivial and the 
second can be shown by simple induction on the structure of trees; 
the proof is highlighting  that reflection on hypothesis is order-irrelevant. 
Transitivity is established by \textit{compositionality} of proof trees and 
reflects the essence of hypothetical reasoning: proof trees of the 
appropriate proposition can be ``plugged in" for assumptions 
to create new, well-formed trees.  
\begin{mdframed}
	\begin{theorem}\label{thm:cmpha}
		If {$\begin{array}{c}{ x:A }\\{\mathcal{D}}
			\\{B \true}
			\end{array}$}
		and {$\begin{array}{c}\PrTri{$\mathcal{E}$}\\{A \true}\end{array}$} 
		are valid proof trees their composition denoted as {$\begin{array}{c}\PrTri{$\mathcal{E}$}\\{A \true}\\{\mathcal{D}}\\{B\true}\end{array}$},  
			defined by substituting all occurrences of $x:A$ for $\mathcal{E}$ in $\mathcal{D}$, is a valid proof tree for $B \true$. 
	\end{theorem}
\end{mdframed}
\subsection{Equating Proof Trees}
Having proof objects as first class citizens, permits for developing logics, essentially, 
as theories of (typed) equality among such objects. 
This idea stemmed from Gentzen's work on natural deduction and 
cut elimination and it is what gives  proofs  computational content. 
Following are the proposed  equalities for the proof relevant \vocab{IPL} 
introduced initially by Gentzen as the driver of the proof  cut elimination. 
We will be revisiting these very same equalities and reframing them 
as equalities among proof terms in the next section. 
Nevertheless, they originated in proof tree form.  
 We show indicatively the equalities regarding the $\supset,\wedge$ connectives reserving the
  rest for the more concise notation.


\begin{mathpar}
	\begin{array}{c c c}
	{\inferrule{
	{\inferrule[]{
		{\begin{array}[b]{c} \overline{x:A}\\ {\mathcal{D}} \\ B \true \end{array}}}{A \supset B \true}}\\
{\begin{array}{c}\mathcal{E}\\{A \true}\end{array}}
}
{ B \true}} & =_{\beta} &
	
			{\begin{array}[b]{c} \mathcal{E} \\ A \true \\ {\mathcal{D}} \\ B \true \end{array}} 

\end{array}
\end{mathpar}
%{\begin{array}[b]{c}  {\mathcal{D}} \\ A\supset B \true \end{array}}
%
%
\begin{mathpar}
	\begin{array}{c c c}
	{\begin{array}[b]{c}  {\mathcal{D}} \\ A\supset B \true \end{array}}
			& =_{\eta} &
		
			{\inferrule{
				{\inferrule[]{
						{\begin{array}[b]{c}  {\mathcal{D}} \\ A\supset B \true \end{array}}
							\\{\overline{x:A}}} 
							{ B \true}}}
				{A \supset B}
		}
		
	\end{array}
\end{mathpar}


\begin{mathpar}
	\begin{array}{c c c}
		{\inferrule{
				{\inferrule[]{
						{\begin{array}[b]{c}  {\mathcal{D}} \\ A \true \end{array}}
							\\{\begin{array}[b]{c}  {\mathcal{E}} \\  B \true \end{array} }
						} 
						{ A\wedge B \true}}}
				{A \true}
		}
			& =_{\beta} &
		
		{\begin{array}[b]{c}  {\mathcal{D}} \\ A\true \end{array}}
		
		
	\end{array}
\end{mathpar}

\begin{mathpar}
	\begin{array}{c c c}
		{\inferrule{
				{\inferrule[]{
						{\begin{array}[b]{c}  {\mathcal{D}} \\ A \true \end{array}}
							\\{\begin{array}[b]{c}  {\mathcal{E}} \\  B \true \end{array} }
						} 
						{ A\wedge B \true}}}
				{B \true}
		}
			& =_{\beta} &
		
		{\begin{array}[b]{c}  {\mathcal{E}} \\ B\true \end{array}}
		
		
	\end{array}
\end{mathpar}

\begin{mathpar}
	\begin{array}{c c c}
		{\begin{array}[b]{c}  {\mathcal{D}} \\ A\wedge B \true \end{array}}
		& =_{\eta} &
		\inferrule{
		\inferrule[]{\inferrule {\mathcal{D}}{ A\wedge B \true}}
		{A \true}\\\inferrule[]{\inferrule {\mathcal{D}}{ A\wedge B \true}}
		{B \true}}{A\wedge B}
	\end{array}
\end{mathpar}


\section{Linear representation of trees  with proof terms: $\lambda$ calculus}
Proof terms provide an alternative, linear representation for proof trees. The simply typed lambda calculus and its equational system can, thus, be viewed as a calculus for proof trees and proof reductions for  intuitionistic logic. What's more, following the doctrine of proof relevance and of characterizing connectives by their proof reductions, i.e. working in the realm of Curry -- Howard Isomorphism, we hit two birds with one stone: we both develop proof relevant logics and we get typed programming languages that reflect their computational content. The ``simplest" language obtained within this program is the simply typed lambda calculus, but we will see that the same doctrine  extends to different logics with different judgmental constructs.
  
\subsubsection{Simply typed lambda calculus}
\begin{mdframed}
\textbf{Type Formation}
\begin{mathpar}
\inferrule*[right=Atom] { } {P_i \in {\sf Type}}
\and
\inferrule*[right=Top] { } {\top \in {\sf Type}}
\and
\inferrule*[right=Bottom] { } {\bot \in {\sf Type}}
\and
\inferrule*[right=Arr] {{A \in {\sf Type }}\\ {B \in {\sf Type}}} {A\rightarrow B\in {\sf Type}}
\and
\inferrule*[right=Prod] {{A \in {\sf Type }}\\ {B \in {\sf Type}}} {A\times B\in {\sf Type}}
\and
\inferrule*[right=Union] {{A \in {\sf Type }}\\ {B \in {\sf Type}}} {A + B\in {\sf Type}}
\end{mathpar}
\end{mdframed}

\begin{mdframed}
\textbf{Context Formation}
\begin{mathpar}
\inferrule*[right=Nil] { } {{\sf nil}\  \context}
\and
\inferrule*[right=$\Gamma$-Add] {{\Gamma\ } {\sf \context}  \\ {A \in {\sf Type}}\\ x\text{ fresh  in }\Gamma} {{\Gamma,\  x:A} \ \context}
\end{mathpar}
\end{mdframed}

\begin{mdframed}
\textbf{Context Reflection}
\begin{mathpar}
\inferrule*[right=$\Gamma$-Refl] { {\Gamma}\ {\sf \context}\\ {x:A  \in \Gamma}}
{\Turnsi {\Gamma} {x:A}}
\end{mathpar}
\end{mdframed}

\begin{mdframed}
\textbf{Top Introduction -- Bottom Elimination}
\begin{mathpar}
\inferrule*[right=$\top$I] { } {\Turnsi {\Gamma} { \langle \rangle:\top }}
\and
\inferrule*[right=$\bot$E] {\Turnsi {\Gamma} {M:\bot } } {\Turnsi {\Gamma} { \operatorname{abort}[A](M) : A}}
\end{mathpar}

\end{mdframed}

\begin{mdframed}
\textbf{Function Construction and Application}
\begin{mathpar}
\inferrule*[right=$\lambda-$Abs] {\Turnsi {\Gamma, x:A } {M:B }} {\Turnsi {\Gamma} { \lambda x:A.\  M:A\rightarrow B }}
\and
\inferrule*[right=App] {\Turnsi {\Gamma} {M:A\rightarrow B }\\{\Turnsi {\Gamma} {M^{'}:A}}} {\Turnsi {\Gamma} {  (M M^{'}):B }}
\end{mathpar}
\end{mdframed}
\begin{mdframed}
\textbf{Tuple Construction and Projections}
\begin{mathpar}
\inferrule*[right=Tup] {\Turnsi {\Gamma} {M:A}\\{\Turnsi {\Gamma} { M^{'}:B}}} {\Turnsi {\Gamma} {  
\langle M,M^{'}\rangle:A\times B }}
\end{mathpar}
\begin{mathpar}
\inferrule*[right=LPrj] {\Turnsi {\Gamma} {M:A\times B }} {\Turnsi {\Gamma} {\operatorname{fst}(M):  A}}
\and
\inferrule*[right=RPrj] {\Turnsi {\Gamma} {M:A\times B}} {\Turnsi {\Gamma} {\operatorname{snd}(M):  B}}
\end{mathpar}
\end{mdframed}
\begin{mdframed}
\textbf{Union Construction and Elimination}
\begin{mathpar}
\inferrule*[right=InjL] {\Turnsi {\Gamma} {M:A}} {\Turnsi {\Gamma} {  
	\operatorname{inj_l}[B](M):A+B}}
\and
\inferrule*[right=InjR] {\Turnsi {\Gamma} {M:B }} {\Turnsi {\Gamma} {\operatorname{inj_r}[A](M) : A+B}}
\end{mathpar}


\begin{mathpar}
\inferrule*[right=$\vee$E] 
{ {\Turnsi {\Gamma} {  M:A + B}}\\
{\Turnsi {\Gamma,x:A } {N:C }}\\
{\Turnsi {\Gamma,y:B} {O:C }}
}
 {\Turnsi {\Gamma} {\text{case }M \text{ of } \operatorname{inj_l}[B]( x)\longmapsto N  |\  \operatorname{inj_r}[A](y)\longmapsto O : C}}
\end{mathpar}

\end{mdframed}
\subsection{Definitional Equality: Proof tree equalities as term equalities}

Gentzen's principles transliterate to an equational system for terms. 
In the following we are defining a congruence relation on proof terms  which is usually coined as \emph{definitional equality} and denoted $M= M':A$. We want definitional equality $=$ to be the least congruence closed under the $\beta, \eta$ rules that directly reflect Gentzen's principles in term form.


\begin{mdframed}
	\textbf{Definition}
     A \emph{congruence} is 
     \begin{itemize} 
     \item	an equivalence relation  (i.e. reflexive, symmetric and transitive) 
     \item	that commutes with  operators  E.g. 
     \begin{mathpar}
     	\inferrule*[]
     	{\Gamma \entails M= M':A}
     	{\Gamma\entails \operatorname{fst}(M)=\operatorname{fst}(M'):A}
     	\end{mathpar} 
     \end{itemize}
\end{mdframed}
  
Informally , we should be able to replace ``equals with equals" everywhere in a term.


\subsubsection{Local Soundness}\label{ge:in}
Local soundness captures the idea that  
``elimination rules are not too strong", which is the informal notion that the 
elimination rules should cancel the introduction rules and give nothing new. 
The so-called  $\beta$ equality rules are as follows:


\begin{mdframed}
	\begin{mathpar}
		
		\inferrule*[right=$\beta\wedge_1$] 
		{{\Turnsi {\Gamma} {  M:A}}\\
			{\Turnsi {\Gamma} {N :B }}  } {{\Turnsi {\Gamma} {\operatorname{fst}(  \langle M,N\rangle)= M:A} }}
		
		\and
		\inferrule*[right=$\beta\wedge_2$] 
		{{\Turnsi {\Gamma} {  M:A}}\\
			{\Turnsi {\Gamma} {N :B }}} { {\Turnsi {\Gamma} {\operatorname{snd}(  \langle M,N\rangle)= N:B} }}
		\and
		\inferrule*[right=$\beta\supset$] 
		{{\Gamma,x:A\vdash M:B}\\ {\Gamma\vdash N:A}}
		{\Gamma\vdash(\lambda x:A .\ M)(N)= [N/x]M:B}
		\and
		\inferrule*
		{ {\Gamma,x
				:A\vdash N:C}\\{\Gamma,y:B \vdash O:C}\\{\Gamma\vdash P:A} }
		{\Gamma\vdash  ({\text{case } \operatorname{inj_l}[B](P) \text{ of } \operatorname{inj_l}[B](x) \longmapsto N  |\  \operatorname{inj_r}[A] (y)\longmapsto O) =[P/x]N: C}}
		\and
		\inferrule*
		{ {\Gamma,x
				:A\vdash N:C}\\{\Gamma,y:B \vdash O:C}\\{\Gamma\vdash Q:B} }
		{\Gamma\vdash  ({\text{case } \operatorname{inj_r}[A](Q) \text{ of } \operatorname{inj_l}[B](x)  \longmapsto N  |\  \operatorname{inj_r}[A](y) \longmapsto O) =[Q/y]O: C}}
	\end{mathpar}
\end{mdframed}

\subsubsection{Local completeness}

Local completeness on the other hand captures the idea that 
``elimination rules are not too weak". Given any proof of a specific type
one should be able to reintroduce it by extracting its constituents 
via elimination rules. Another way to see this is that canonical
forms of a certain type structure should have certain shape. 


The $\eta$ rules (a.k.a. \textit{identity expansion}) are given below. We assume that in the $\eta\rightarrow$ case
the variable $x$ does not appear free in the term $M$:

\begin{mdframed}
	\begin{mathpar}
		\inferrule*[right=$\eta\top$]{\Gamma\vdash M:\top}{\Gamma\vdash M= \langle \ \rangle: \top} 
		\and
		
		\inferrule*[right=$\eta\times$]{\Gamma\vdash M:A\times B}{\Gamma\vdash M= \langle \operatorname{fst}(M),\operatorname{snd}(M)\rangle :A\times B }
		\and
		\inferrule*[right=$\eta\rightarrow$]{\Gamma\vdash M:A\rightarrow B}{\Gamma\vdash M= \lambda x:A. M x: A\rightarrow B} 
		\and
		\inferrule*[right=$\eta\vee$]
		{\Gamma\vdash M:A+B}
		{{
				\begin{tabular}[b]{ rl}
					$\Gamma\vdash M = \text{case }  M \text{ of }$  & $| \operatorname{inj_l}[B](x) \mapsto \operatorname{inj_l}[B](x)$
					\\
					& $ \operatorname{inj_r}[A](y)\mapsto \operatorname{inj_r}[A](y) : A+ B $
					\\
				\end{tabular}
			}
		}
		
	\end{mathpar}
\end{mdframed}

\section{Operational (a.k.a ``term") Semantics} 
It is obvious that the system is consistent in terms of provability. It's forgetful projection is exactly \ac{IPL} for which we have provided order-theoretic models. We would like to show consistency for the proof relevant model. One way is operational semantics.
We will be discussing only the $\rightarrow$, $\wedge$ fragment.

The first step toward operational semantics is to break the symmetry of the definitional equivalence and construct a one-way reduction 
relation  on lambda terms. 
Towards this definition we first define the notion of a  \textit{redex}\footnote{we only present it for the $\times\rightarrow$ part of the calculus}: 
\begin{mdframed}
\begin{definition}	
\begin{itemize}
\item A $\beta$-redex is every term of the form:  $$(\lambda x:A. N) M |  \operatorname{fst}(\langle M, N \rangle)| \operatorname{snd}(\langle M, N \rangle) $$
\item  An $\eta$-redex is every term of the form:
$$\lambda x:A. M x | \langle \operatorname{fst}  M, \operatorname{snd} M \rangle  $$    
\end{itemize}
\end{definition}	
\end{mdframed}
A \textit{normal form} is a term where no redex occurs. To make the
term surrounding the redex explicit, we can use a \textit{term context}, 
i.e. a term with a single term hole, such as $\lambda x:A.[\bullet]$, $(e[\bullet])$, $[\bullet]e$, where  a hole can be substituted for a term to give a larger term. To be strict all single hole terms have the following diagram:
$$H:= [\bullet]|\ (M[\bullet])|\  ([\bullet]M)|\ \lambda x:A. H|\  \langle H, M \rangle |\  \langle  M, H \rangle $$

Now we have enough tools to define the \textit{(one-step) $\beta\eta$-reduction} 
between two terms that include redexes as follows:
\begin{mdframed}
	\textbf{One-step $\mapsto_{\beta\eta}$  reduction}
	\begin{mathpar}
		\inferrule*[right=($\beta$)]{} {(\lambda x: A. N) M \mapsto [M/x]N }
	\end{mathpar}
	\begin{mathpar}
		\inferrule*[right=($\beta$)] {}{\operatorname{fst}\langle M, N \rangle\mapsto M}
		\and
		\inferrule*[right=($\beta$)] {}{\operatorname{snd}\langle M, N \rangle\mapsto N}
	\end{mathpar}	
	\begin{mathpar}
		\inferrule*[right=($\eta$)]{}{\lambda x: M x\mapsto M}
        
		\inferrule*[right=($\eta$)]{} { \langle \operatorname{fst} M, \operatorname{snd} M\rangle\mapsto M }  
	\end{mathpar}
	\begin{mathpar}
		\inferrule*[right=(subterm)]{M\mapsto M^{'}}{H[M]\mapsto H[M^{'}]}
	\end{mathpar}
\end{mdframed}

Now we can define the  reflexive, transitive closure of the previous relation as $\mapsto_{\beta\eta}^{*}$ to denote zero or more reduction steps. The following facts -- leading to a computational proof of consistency -- hold:

\begin{mdframed}
	\begin{theorem}	\textbf{Church -- Rosser for $\mapsto_{\beta\eta}$}
		For every term $M$, if $M\mapsto_{\beta\eta} N_1$ and $M \mapsto_{\beta\eta} N_2$ then there exists $N^{'}$ s.t. $N_1 \mapsto N^{'}$ and $N_2\mapsto N^{'}$
		
	\end{theorem}	
	\begin{theorem}	\textbf{Church -- Rosser for $\mapsto_{\beta\eta}^{*}$}
		For every term $M$, if $M\mapsto_{\beta\eta}^{*} N_1$ and $M \mapsto_{\beta\eta}^{*} N_2$ then there exists $N^{'}$ s.t. $N_1 \mapsto_{\beta\eta}^{*} N^{'}$ and $N_2\mapsto_{\beta\eta}^{*} N^{'}$
		
	\end{theorem}	
\end{mdframed}
 The first consistency result for the equational system comes straight from the Church--Rosser properties. 
 Since it is  easy to show that for any terms $M$, $N$ s.t.  $\Gamma\vdash M= N: A$, 
 based on the $=$ axiomatization, there exists a finite sequence of terms $N_0,\ldots, N_i$ such that $M\mapsto_{\beta\eta}^{*}N_0\mapsfrom_{\beta\eta}^{*} N_1\mapsto_{\beta\eta}^{*} N_2\mapsfrom_{\beta\eta}^{*}\ldots \mapsfrom_{\beta\eta} N_i$. Now we can obtain:
 \begin{mdframed}
 \begin{theorem}	\textbf{Definitional equality implies common contractum}
 	For any terms, $M$,$N$ if $\Gamma\vdash M= N:A$ then there exists term $L$ s.t. $M,N\mapsto_{\beta\eta}^{*} L$
 	
 \end{theorem}
\end{mdframed}
 And as a result:
 \begin{mdframed}	
 \begin{theorem}	\textbf{Consistency of definitional equality of terms}
 	The definitional equality $=$ is not trivial i.e. it won't equate any two terms.
 \end{theorem}	
\end{mdframed}
Moving toward consistency of the whole system (i.e. there is not term of type $\bot$), we prove a theorem for the existence of normal forms.
\begin{mdframed}	
\begin{theorem}	\textbf{Weak normalization theorem}
For any term $M$, there exists a finite sequence of terms s.t. $M\mapsto_{\beta}N_0\mapsto_{\beta} N_1\mapsto_{\beta} N_2\mapsto_{\beta}\ldots \mapsto_{\beta} N_i$ where $N_i$ is a $\beta$ normal form.
\end{theorem}	
\end{mdframed}
It is common place in metatheoretic proofs for such systems that induction on the structure of the term does not ``go through''. 
Intuitively, a reduction can be ``enlarging" the term  yet, 
it is doing progress based on a different kind of metric. 
 The idea is that we can choose a reduction strategy 
such that the number of \textit{redexes of a specific type} 
(to be defined soon) reduce. Here are the steps towards the proof. We omit redexes related to disjunction but the proof extends to such cases pretty easily.


\begin{mdframed}
	\textbf{Definition}
	The \textit{degree of a type $A$} is defined as follows:
	\begin{itemize}
		\item $\theta(P_i)=1$ if $P_i$ is atomic
		\item $\theta(A\times B)=\theta(A \rightarrow B)= \theta(A)+\theta(B)+1$
	\end{itemize}
\end{mdframed}
\begin{mdframed}
	\textbf{Definition}
	The \textit{degree of a redex} is defined as follows:
	\begin{itemize}
		\item  Given that the type of $\lambda x. M$ is of type $A\rightarrow B$ then  $d((\lambda x. M)N)=\theta(A\rightarrow B)$
		\item Similarly, $d(\operatorname{fst}\langle M, N\rangle)=\theta(A\times B)$
		where $A\times B$ is the type of $\langle M, N\rangle$
		
		\item Similarly for the other kinds of redexes.
	\end{itemize}
\end{mdframed}
\begin{mdframed}
	\textbf{Definition}
	The \textit{degree of a term} $d(t)$ is defined as the supremum of the degrees of its redexes.
\end{mdframed}
Now we can prove the following facts:
\begin{theorem}
	\begin{mdframed}
\begin{enumerate}
	\item The degree of redex $r$ is strictly larger than the degree of its type $A$: 
	$\theta(A)<d(r)$
	\item The degree of a redex ($r$) seen as term ($t$)  can be smaller than its redex degree since it might include other redexes: $d(r)\le d(t)$.
	\item The term resulting from a substitution $M[N/x]$  has degree : $d(M[N/x])\le max(d(M),d(N),\theta(A))$ where $A$ is the declared type of $x$ in the type context.
\end{enumerate}
	\end{mdframed}
\end{theorem}
\begin{mdframed}
	\begin{theorem}
If $M\mapsto M^{\prime}$ then $d(M)<d(N)$ and hence, if $M\mapsto^{+} N$ then $d(M)<d(N)$.
\end{theorem}
\end{mdframed}
As a result we get a weak  normalization theorem by induction on pairs $(d(M),k)$ where $k$ is the number of redexes with degree $d(M)$.
\begin{mdframed}
\begin{theorem}
	\textbf{Weak Normalization Theorem}
For every term $\Gamma\vdash M:A$ there exists a normalization strategy 
such that $M\mapsto_{\beta}^{*}N$ and $N$ is a normal form.
\end{theorem}
\end{mdframed} 

Combining with previous results we get:
\begin{theorem}
\begin{mdframed}
\textbf{Consistency}
There is no (closed) term $M$ for which $\vdash M:\bot$ 
\end{mdframed}
\end{theorem}
 Suppose the opposite and obtain a contradiction 
 using the previous theorem; there is no way to obtain a normal form of a bottom type from the rules.  
 
 A stronger result is the strong normalization theorem which states that \textit{every} 
 strategy is normalizing. This result is relevant to concurrent 
 implementations of reduction since it implies that the order 
 in which redexes are consumed does not matter during the evaluation of  expression. 
 
 The important idea behind the technique -- that generalizes to proof of 
 strong normalization for more complex calculi-- is the concept of  reducibility predicates (see, e.g. ~\cite{prawitz1971ideas}). 
 

\subsection{The essence of proofs--as--programs }
The proofs of normalization above are essentially of the same 
\say{proof strength}  as the logical proof of cut elimination. 
In a nutshell, eliminating cuts is the same as normalizing proof 
terms (or, correspondingly, proof trees).

In reality, the slogan of the Curry-Howard isomorphism and, 
in general, of a type theoretic treatment to logic should be \say{Normalization as Cut Elimination}. 
This aspect of the isomorphism can be articulated 
nicely following Sieg's extraction method ~\cite{Sieg1998}, which  
showcases how a construction of a Cut-free sequent 
calculus comes naturally from an analysis of normal proofs 
in natural deduction. 
